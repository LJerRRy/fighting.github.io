---
layout: post
title: java线程二——锁的机制
subtitle: Java Thread
date: 2017-03-28 11:13:05
author: "Jerry"
catalog:    true
use_math: false
header-img: "img/post-bg-digital-native.jpg"
tags:
    - 面试准备
    - Java
---

> 一段synchronized的代码被一个线程执行之前，他要先拿到执行这段代码的权限，在Java里边就是拿到某个同步对象的锁（一个对象只有一把锁）； 如果这个时候同步对象的锁被其他线程拿走了，他（这个线程）就只能等了（线程阻塞在锁池等待队列中）。 取到锁后，他就开始执行同步代码(被synchronized修饰的代码）；线程执行完同步代码后马上就把锁还给同步对象，其他在锁池中等待的某个线程就可以拿到锁执行同步代码了。这样就保证了同步代码在统一时刻只有一个线程在执行。

## 锁的分类
java中锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

1. 锁自旋

我们知道在当某个线程在进入同步方法/代码块时若发现该同步方法/代码块被其他现在所占，则它就要等待，进入阻塞状态，这个过程性能是低下的。

在遇到锁的争用或许等待事，线程可以不那么着急进入阻塞状态，而是等一等，看看锁是不是马上就释放了，这就是锁自旋。锁自旋在一定程度上可以对线程进行优化处理。

2. 偏向锁

**偏向锁主要为了解决在没有竞争情况下锁的性能问题。**在大多数情况下锁锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当某个线程获得锁的情况，该线程是可以多次锁住该对象，但是每次执行这样的操作都会因为**CAS（CPU的Compare-And-Swap指令）**操作而造成一些开销消耗性能，为了减少这种开销，这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

当有其他线程在尝试着竞争偏向锁时，持有偏向锁的线程就会释放锁。

3. 锁膨胀

多个或多次调用粒度太小的锁，进行加锁解锁的消耗，反而还不如一次大粒度的锁调用来得高效。

4. 轻量级锁

轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。轻量级锁在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的指向和状态。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="64">
<p align="left">锁</p>
</td>
<td valign="top" width="113">
<p align="left">优点</p>
</td>
<td valign="top" width="137">
<p align="left">缺点</p>
</td>
<td valign="top" width="106">
<p align="left">适用场景</p>
</td>
</tr>
<tr>
<td valign="top" width="64">
<p align="left">偏向锁</p>
</td>
<td valign="top" width="113">
<p align="left">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</p>
</td>
<td valign="top" width="137">
<p align="left">如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</p>
</td>
<td valign="top" width="106">
<p align="left">适用于只有一个线程访问同步块场景。</p>
</td>
</tr>
<tr>
<td valign="top" width="64">
<p align="left">轻量级锁</p>
</td>
<td valign="top" width="113">
<p align="left">竞争的线程不会阻塞，提高了程序的响应速度。</p>
</td>
<td valign="top" width="137">
<p align="left">如果始终得不到锁竞争的线程使用自旋会消耗CPU。</p>
</td>
<td valign="top" width="106">
<p align="left">追求响应时间。</p>
<p align="left">同步块执行速度非常快。</p>
</td>
</tr>
<tr>
<td valign="top" width="64">
<p align="left">重量级锁</p>
</td>
<td valign="top" width="113">
<p align="left">线程竞争不使用自旋，不会消耗CPU。</p>
</td>
<td valign="top" width="137">
<p align="left">线程阻塞，响应时间缓慢。</p>
</td>
<td valign="top" width="106">
<p align="left">追求吞吐量。</p>
<p align="left">同步块执行速度较长。</p>
</td>
</tr>
</tbody>
</table>

### 线程同步解决方法
众所周知，在Java多线程编程中，一个非常重要的方面就是线程的同步问题。
关于线程的同步，一般有以下解决方法：

1. 在需要同步的方法的方法签名中加入synchronized关键字。

2. 使用synchronized块对需要进行同步的代码段进行同步。

3. 使用JDK 5中提供的java.util.concurrent.lock包中的Lock对象。

另外，为了解决多个线程对同一变量进行访问时可能发生的安全性问题，我们不仅可以采用同步机制，更可以通过JDK 1.2中加入的ThreadLocal来保证更好的并发性。




### 线程的先来后到

我们来举一个Dirty的例子：某餐厅的卫生间很小，几乎只能容纳一个人如厕。为了保证不受干扰，如厕的人进入卫生间，就要锁上房门。我们可以把卫生间想 象成是共享的资源，而众多需要如厕的人可以被视作多个线程。假如卫生间当前有人占用，那么其他人必须等待，直到这个人如厕完毕，打开房门走出来为止。这就 好比多个线程共享一个资源的时候，是一定要分出先来后到的。

有人说：那如果我没有这道门会怎样呢？让两个线程相互竞争，谁抢先了，谁就可以先干活，这样多好阿？但是我们知道：如果厕所没有门的话，如厕的人一起涌向 厕所，那么必然会发生争执，正常的如厕步骤就会被打乱，很有可能会发生意想不到的结果，例如某些人可能只好被迫在不正确的地方施肥……

正是因为有这道门，任何一个单独进入如厕的人都可以顺利的完成他们的如厕过程，而不会被干扰，甚至发生以外的结果。这就是说，如厕的时候要讲究先来后到。


那么在Java 多线程程序当中，当多个线程竞争同一个资源的时候，如何能够保证他们不会产生“打架”的情况呢？有人说是使用同步机制。没错，像上面这个例子，就是典型的 同步案例，一旦第一位开始如厕，则第二位必须等待第一位结束，才能开始他的如厕过程。一个线程，一旦进入某一过程，必须等待正常的返回，并退出这一过程， 下一个线程才能开始这个过程。这里，最关键的就是卫生间的门。其实，卫生间的门担任的是资源锁的角色，只要如厕的人锁上门，就相当于获得了这个锁，而当他 打开锁出来以后，就相当于释放了这个锁。

也就是说，多线程的线程同步机制实际上是靠锁的概念来控制的。那么在Java程序当中，锁是如何体现的呢？

### JVM角度看锁
让我们从JVM的角度来看看锁这个概念：

在Java程序运行时环境中，JVM需要对两类线程共享的数据进行协调：
1）保存在堆中的实例变量
2）保存在方法区中的类变量

这两类数据是被所有线程共享的。
（程序不需要协调保存在Java 栈当中的数据。因为这些数据是属于拥有该栈的线程所私有的。）

在java虚拟机中，每个对象和类在逻辑上都是和一个监视器相关联的。
对于对象来说，相关联的监视器保护对象的实例变量。

对于类来说，监视器保护类的类变量。

（如果一个对象没有实例变量，或者一个类没有变量，相关联的监视器就什么也不监视。） 
为了实现监视器的排他性监视能力，java虚拟机为每一个对象和类都关联一个锁。代表任何时候只允许一个线程拥有的特权。线程访问实例变量或者类变量不需锁。

但是如果线程获取了锁，那么在它释放这个锁之前，就没有其他线程可以获取同样数据的锁了。（锁住一个对象就是获取对象相关联的监视器）

类锁实际上用对象锁来实现。当虚拟机装载一个class文件的时候，它就会创建一个java.lang.Class类的实例。当锁住一个对象的时候，实际上锁住的是那个类的Class对象。

**一个线程可以多次对同一个对象上锁。对于每一个对象，java虚拟机维护一个加锁计数器，线程每获得一次该对象，计数器就加1，每释放一次，计数器就减 1，当计数器值为0时，锁就被完全释放了。**

java编程人员不需要自己动手加锁，对象锁是java虚拟机内部使用的。

在java程序中，只需要使用synchronized块或者synchronized方法就可以标志一个监视区域。当每次进入一个监视区域时，java 虚拟机都会自动锁上对象或者类。

**当一个有限的资源被多个线程共享的时候，为了保证对共享资源的互斥访问，我们一定要给他们排出一个先来后到。而要做到这一点，对象锁在这里起着非常重要的作用。**


### 对象锁和类锁

在上一小节中，我们讲到了多线程是如何处理共享资源的，以及保证他们对资源进行互斥访问所依赖的重要机制：对象锁。本小节中，我们来看一看传统的同步实现方式以及这背后的原理。



很多人都知道，在Java多线程编程中，有一个重要的关键字，synchronized。但是很多人看到这个东西会感到困惑：“都说同步机制是通过对象锁来实现的，但是这么一个关键字，我也看不出来Java程序锁住了哪个对象阿？“


没错，我一开始也是对这个问题感到困惑和不解。不过还好，我们有下面的这个例程：

```java
public class ThreadTest extends Thread {   
    private int threadNo;   
    public ThreadTest(int threadNo) {   
        this.threadNo = threadNo;   
    }   
    public static void main(String[] args) throws Exception {   
        for (int i = 1; i < 10; i++) {   
           new ThreadTest(i).start();   
            Thread.sleep(1);   
        }   
     }   
    
    @Override  
     public synchronized void run() {   
        for (int i = 1; i < 10000; i++) {   
            System.out.println("No." + threadNo + ":" + i);   
        }   
     }   
 }
 ```   
这个程序其实就是让10个线程在控制台上数数，从1数到9999。理想情况下，我们希望看到一个线程数完，然后才是另一个线程开始数数。但是这个程序的执行过程告诉我们，这些线程还是乱糟糟的在那里抢着报数，丝毫没有任何规矩可言。

但是细心的读者注意到：run方法还是加了一个synchronized关键字的，按道理说，这些线程应该可以一个接一个的执行这个run方法才对阿。

但是通过上一节中，我们提到的，**对于一个成员方法加synchronized关键字，这实际上是以这个成员方法所在的对象本身作为对象锁。**在本例中，就是 以ThreadTest类的一个具体对象，也就是该线程自身作为对象锁的。一共十个线程，每个线程持有自己 线程对象的那个对象锁。这必然不能产生同步的效果。换句话说，如果要对这些线程进行同步，那么这些线程所持有的对象锁应当是共享且唯一的！ 

我们来看下面的例程：

```java
public class ThreadTest2 extends Thread {   
 private int threadNo; private String lock;   
 public ThreadTest2(int threadNo, String lock) {   
  this.threadNo = threadNo;   
     this.lock = lock;   }   
public static void main(String[] args) throws Exception {   
   String lock = new String("lock");   
     for (int i = 1; i < 10; i++) {     
  new ThreadTest2(i, lock).start();   
      Thread.sleep(1);   
     }   
  }     
public void run() {     
 synchronized (lock) {   
      for (int i = 1; i < 10000; i++) {   
       System.out.println("No." + threadNo + ":" + i);   
    }      
 }     
 }   
 }  
```

我们注意到，该程序通过在main方法启动10个线程之前，创建了一个String类型的对象。并通过ThreadTest2的构造函数，将这个对象赋值 给每一个ThreadTest2线程对象中的私有变量lock。根据Java方法的传值特点，我们知道，这些线程的lock变量实际上指向的是堆内存中的 同一个区域，即存放main函数中的lock变量的区域。

程序将原来run方法前的synchronized关键字去掉，换用了run方法中的一个synchronized块来实现。这个同步块的对象锁，就是 main方法中创建的那个String对象。换句话说，他们指向的是同一个String类型的对象，对象锁是共享且唯一的！

于是，我们看到了预期的效果：10个线程不再是争先恐后的报数了，而是一个接一个的报数。

再来看下面的例程：
```java
1 public class ThreadTest3 extends Thread {   

 2    
 3     private int threadNo;   
 4     private String lock;   
 5    
 6     public ThreadTest3(int threadNo) {   
 7         this.threadNo = threadNo;   
 8     }   
 9    
10     public static void main(String[] args) throws Exception {   
11        
12         for (int i = 1; i < 20; i++) {   
13             new ThreadTest3(i).start();   
14             Thread.sleep(1);   
15         }   
16     }   
17    
18     public static synchronized void abc(int threadNo) {   
19         for (int i = 1; i < 10000; i++) {   
20               
21                 System.out.println("No." + threadNo + ":" + i);           
22         }   
23     }   
24    
25     public void run() {   
36         abc(threadNo);   
27     }   
28 } 
```

细心的读者发现了：这段代码没有使用main方法中创建的String对象作为这10个线程的线程锁。而是通过在run方法中调用本线程中一个静态的同步方法abc而实现了线程的同步。我想看到这里，你们应该很困惑：这里synchronized静态方法是用什么来做对象锁的呢？

我们知道，对于同步静态方法，对象锁就是该静态放发所在的类的Class实例，由于在JVM中，所有被加载的类都有唯一的类对象，具体到本例，就是唯一的 ThreadTest3.class对象。不管我们创建了该类的多少实例，但是它的类实例仍然是一个！

### 总结

1. 对于同步的方法或者代码块来说，必须获得对象锁才能够进入同步方法或者代码块进行操作；

2. 如果采用method级别的同步，则对象锁即为method所在的对象，如果是静态方法，对象锁即指method所在的
Class对象(唯一)；

3. 对于代码块，对象锁即指synchronized(abc)中的abc；

4. 因为第一种情况，对象锁即为每一个线程对象，因此有多个，所以同步失效，第二种共用同一个对象锁lock，因此同步生效，第三个因为是
static因此对象锁为ThreadTest3的class 对象，因此同步生效。

如上述正确，则同步有两种方式，同步块和同步方法（为什么没有wait和notify？这个我会在补充章节中做出阐述）

如果是同步代码块，则对象锁需要编程人员自己指定，一般有些代码为synchronized(this)只有在单态模式才生效；
（本类的实例有且只有一个）

如果是同步方法，则分静态和非静态两种 。

静态方法则一定会同步，非静态方法需在单例模式才生效，推荐用静态方法(不用担心是否单例)。

所以说，在Java多线程编程中，最常见的synchronized关键字实际上是依靠对象锁的机制来实现线程同步的。
我们似乎可以听到synchronized在向我们说：“给我一把 锁，我能创造一个规矩”。